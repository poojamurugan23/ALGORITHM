# -*- coding: utf-8 -*-
"""Experiment : 1 - (Seaching_and_Sorting_Algorithm).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LxGJlGEgtF1ec_1r_59-pQc0rzkKqwfE
"""

import time
import matplotlib.pyplot as plt
def linear_search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
    return -1
def measure_time(n):
    arr = [i for i in range(n)]
    start_time = time.time()
    linear_search(arr, n + 1)
    return time.time() - start_time
def time_taken(arr, x):
    start_time = time.time()
    linear_search(arr, x)
    return time.time() - start_time
if __name__ == '__main__':
    n_values = [10, 100, 1000, 10000, 100000, 1000000]
    times = [measure_time(n) for n in n_values]
    print(n_values)
    print(times)
    arr = [i for i in range(1000000)]
    x = 999999
    print(f"Time taken to find {x} in arr using linear search: {time_taken(arr, x)} seconds")
    plt.plot(n_values, times)
    plt.xlabel('n - number of elements in list')
    plt.ylabel('Time taken (in seconds)')
    plt.title('Linear search performance')
    plt.show()

import time
import matplotlib.pyplot as plt
def binary_search_recursive(arr, x, left, right):
    if right >= left:
        mid = (left + right) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return binary_search_recursive(arr, x, left, mid - 1)
        else:
            return binary_search_recursive(arr, x, mid + 1, right)
    else:
        return -1
def measure_time(n):
    arr = [i for i in range(1, n + 1)]
    x = arr[-1]  # searching for the last element
    start = time.time()
    binary_search_recursive(arr, x, 0, len(arr) - 1)
    end = time.time()
    return end - start
n_values = [10, 100, 1000, 10000, 100000, 1000000]
time_values = [measure_time(n) for n in n_values]
print(n_values)
print(time_values)
plt.plot(n_values, time_values)
plt.xscale('log')
plt.xlabel('Number of elements (log scale)')
plt.ylabel('Time taken (seconds)')
plt.title('Recursive Binary Search Performance')
plt.show()

import time
def search(pattern, text):
    m = len(pattern)
    n = len(text)
    for i in range(n - m + 1):
        j = 0
        while j < m and text[i + j] == pattern[j]:
            j += 1
        if j == m:
            print(f"Pattern found at index {i}")
def time_taken(pattern, text):
    print("Time taken to find pattern")
    start = time.time()
    search(pattern, text)
    end = time.time()
    return end - start
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
elapsed_time = time_taken(pattern, text)
print(f"Time taken: {elapsed_time:.6f} seconds")

import random
import time
import matplotlib.pyplot as plt
def insertion_sort(arr):
    for i in range(1, len(arr)):
        j = i - 1
        while j >= 0 and arr[j] > arr[i]:
            arr[j], arr[j+1] = arr[j+1], arr[j]
            j -= 1
n_values = [10, 100, 1000, 10000]
times = []
for n in n_values:
    arr = [random.randint(0, 1000) for _ in range(n)]
    start_time = time.time()
    insertion_sort(arr)
    end_time = time.time()
    elapsed_time = end_time - start_time
    times.append(elapsed_time)
    print(f"n={n}: {elapsed_time} seconds")
plt.plot(n_values, times)
plt.xlabel('n')
plt.ylabel('Time (seconds)')
plt.title('Insertion sort time complexity')
plt.show()

import random
import time
import matplotlib.pyplot as plt
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2
    if l < n and arr[largest] < arr[l]:
        largest = l
    if r < n and largest < n and arr[largest] < arr[r]:
        largest = r
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
def heap_sort(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
n_values = [1000, 2000, 3000, 4000, 5000]
times = []
for n in n_values:
    arr = [random.randint(1, 10000) for _ in range(n)]
    start_time = time.time()
    heap_sort(arr)
    end_time = time.time()
    times.append(end_time - start_time)
    print(f"n={n}: {end_time - start_time} seconds")
plt.plot(n_values, times)
plt.xlabel('n')
plt.ylabel('Time (s)')
plt.title('Heap Sort Time Complexity')
plt.show()